#include <iostream>

class Id {
    // public члены класса доступны в любой части кода
public:
    // Конструктор по умолчанию
    Id() {
        value_ = defaultValue;
    }

    // explicit отключает автоматическое преобразование типа для этого конструктора
    explicit Id(int value) {
        value_ = value;
        // this->value_ = value; // Можно и через указатель this
    }

    int getValue() const {
        return value_;
    }

    void setValue(int value) {
        value_ = value;
    }

    // Доступ к protected членам класса имеют только наследники
protected:
    int value_;

    // Доступ к private членам класса закрыт для всех вне этого класса (кроме friend функций и friend классов)
private:
    int defaultValue = 0;
};

int main() {
    using namespace std;

    Id id1(1);
    // Скопируется объект, не его ссылка!
    // Компилятор автоматически генерирует оператор присвоения =,
    // конструктор копирования для экземляров того же класса,
    // деструктор
    // (а также оператор присвоения перемещением и конструктор перемещения для c++ 11 стандарта и выше)
    // Если вы переопределяете один из этих методов, то вы должны переопределить все 3 метода
    // (Или 5 для c++ 11 стандарта и выше)
    // Это необходимо делать вручную, если внутри вашего класса объявлены
    // динамически создаваемые переменные (через new),
    // или вам нужно переопределить поведение этих функций для своих целей.
    // См. файл rule_of_five.cpp
    Id id2 = id1;
    id1.setValue(2);
    cout << "id1.getValue() = " << id1.getValue() << endl;
    cout << "id2.getValue() = " << id2.getValue() << endl;

    return 0;
}